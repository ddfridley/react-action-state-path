__DEMO__ (http://react-action-state-path.herokuapp.com)
# react-action-state-path
A state and history management package for React for use when:
* components choose children dynamically based on user input
* the URL should update based on user actions and take a user back to where they left off
* the URL to a deep position should not be impossibly long and shouldn't contain sensitive stuff (not JSON.stringify()) 
* components have external information that needs to be fetched when restoring a deep URL (restoring state based on path can wait for each compoents key state to be set )
* users want the back and forward buttons of the browser to work
* components want send actions to parents or children (yes you can easially RESET children)
* parent state may change based on child actions
* you want to use something like the redux action -> state pattern to make code simplier to follow (it really does)

__If your working on one of those web sites that looses everyting I typed in when I hit the back button, THIS IS FOR YOU!__

The basic idea is, create a component with a `<ReactActionStatePath>` component as its parent.  This is where the state information is saved, and this is where all the work is done for corrdinating with all the other RASP components, pushing and poping state to/from the browser history, updating the path, and disecting a new URL into path segments and getting each component to fetch it's external data and set it's state based on what's in the path.

Then in the component you are creating, there are two functions you need to supply:
1. `segmentToState()`:  converts the path segment information generated by the component into state information.
2. `actionToState()`: based on the action, and the current state, return the new state.

the `<ReactActionStatePathClient>` base class provides these userful resources:
This component should be used when there will only be one 'active' child at a time. - Meaning that state and path from no more than on child will be saved/restored.
1. `this.toChild[key]` an array of all the child RASP components of this component. Actions can be sent to children with this.toChild[key](action) such as RESET_SHAPE
2. `this.raspChild(shape, key)` used to get the rasp object to pass to a child
3. `this.toMeFromChild()` to send actions to change component state. eg: `onClick={()=>this.toMeFromChild({action: "TOGGLE})}`

# Demo
http://react-action-state-path.herokuapp.com

This is a demo of nested text, like an outline.  The demo shows the root Article.  An article contains a subject and text and has an id and a parent id.  When you click on the subject an an Article, the text is shown, and the SubArticleList of Articles that have this as a parent is retrieved. When you click on the subject of a sub Article, the text and SubArticleList of that Article are shown, and the grand parent Article's text will collapse again.

The data for the Articles is retrieved through ArticleStore, which gets it's data from an array, but more normally this data would come from a data base.  These components, `<ArticleStore>`, `<SubArticleList>`, and `<Article>` are recursively called, the deeper you go. 

You can move through the articles by clicking on the subject to expand/contract each one. You can use the forward and back browser buttons. The URL is updated with every user action, and you can save the URL and go back to it.

The [react-proactive-accordion](http://github.com/ddfridley/react-proactive-accordion) component is used to encapulate the `<Article>` and it's text in order to smooth out their appearance and disappearance.  If things just appear and disappear it takes time for people to recognize what's changed.

If you git fork https://github.com/ddfridley/react-action-state-path you can open the file dist/demo/demo.html .  You can also run 
    node dist/server.js 
to fire up a server. Then onpen http://localhost:5000

Or you can push your repo to heroku:

    heroku create
    heroku config:set NPM_CONFIG_PRODUCTION=false
    git push heroku master

And go to the URL they created for you when you ran heroku create.
You must set NPM_CONFIG_PRODUCTION to false, because other wise npm/heroku won't install the dev dependencies otherwise.

# Usage
component-name.jsx:

    import React from 'react';
    import {ReactActionStatePath, ReactActionStatePathClient} from 'react-action-state-path';

    export default class ComponentName extends React.Component {
        render() {
            return (
                <ReactActionStatePath {...this.props} initialRASP={this.initialRASP} >
                    <RASPComponentName />
                </ReactActionStatePath>
            )
        }
    }

    class RASPComponentName extends ReactActionStatePathClient {
        constructor(props) {
            super(props, 'key' [, debugLevel]);    // the 'key' is the name of the property name used to identify the children. left out it will be 'key'
        }

        segmentToState(action) {  // return the state for the component based on it's action.segment part of the url when starting from a specific URL
            var nextRASP= // calculate the RASP state based on action.segment for this component
            nextRASP.shape=// calculate the shape
            nextRASP.pathSegment= // calculate the path segment, don't copy action.segment, make sure you ignore the junk
            return { nextRASP, setBeforeWait: false };  //setBeforeWait means set the new state and then wait for the key child to appear, otherwise wait for the key child to appear and then set the new state.
        }
        
        actionToState(action, rasp, source, initialRASP) {   // return the next state for the component, based on the action, the current rasp state, the source (PARENT || CHILD), and the initialRASP state;
            var nextRASP={}, delta={};
            if(action.type==="ACTION_NAME"){ 

                action.key // is the identity of the source of the action
                toChild[child-key](action) // will send an action to a child
                this.props.rasp.toParent(action) // will send an action to a parent
                
            } else if (...)

            } else 
                return null; // if the action is not specifically know by this component return null to pass it on

            //
            // derive this state information in one spot for all action types - this makes it a lot easier to be consistent
            //
            delta.shape= // compute shape. this is the one property of a state that could have meaning to other states. (example: 'open' or 'truncated')
            delta.pathSegment = // compute segment for URL it'called pathSemgnet in a state and segment when it's passed in an action.
            Object.assign(nextRASP, rasp, delta);  // return a new state, don't change special properies in the state like depth
            return nextRASP; // return the new state
        }

        //
        // this.props.rasp is what is passed from parent to child that connects everything together and holds the state information for this Component
        //
        // when this component renders it should be based on the state information in this.props.rasp 
        //    for example here, the background color of the items in the list is based on a rasp state.
        // when this component renders children, it should pass a new rasp to them, setting the initial shape, and passing toMeFromChild from the parent class.
        //
        render(){
            const {rasp, items, ... } = this.props;
            return(
                {items.map(item->{
                    <Item item={item} rasp={this.raspChild('truncated',item.key)} key={item.key} style={{backgroundColor: rasp.backgroundColor}}> // key={} is for react so it can track what's changed
                })}
            )
        }
    }

## action

    {   type: "ACTION_NAME",
        [key]: key, the key of the child the originated the action (example _id and an ObjectId)
        shape: the new value of shape from the component that changed shape
        distance: undefined when generated an event by default (like a button click)
                0 : action applies to this component
                1 : action applied to the immediate child
                -n: ignore the action and send it to parent component
        toBeContinued: false/undefined - default
                    true : do not generate a CHILD_SHAP_CHANGED action yet, another action will follow
        [stuff]: children are welcome to include other relevant info in actions
    }

These are the inherent actions:

* RESET_STATE:  Reset the state of a component, can be sent to a child or a parent
* CHILD_SHAPE_CHANGED:  If a child's shape changes, this action is generated and propgated up, with distance increasing each time.  You would use this to reduce, or hide, or change components that are far from the action
* CLEAR_PATH:    Reset the state of a component's children, and then the component. (order matters)
* SET_PATH: Used when restoring state from a URL, SET_PATH is called for each component

# Guidelines

* render children first, then self, then return to parent
* component children that are not in the active path will get their rasp state reset to initialRASP on user navigation (there is a new parent class coming for components that want to retain state of all children)
* when sending an action to a parent use setTimeout(()=>this.props.rasp.toParent({type: "ACTION_NAME", distance: -1, ...})) so that the action will take place after the children and the current component have rendered. distance: -2 will skip the immediate parent and go to the grandparent, etc.
* make sure you set the React key of children, or react will do funny things with them.

# Debugging

* When you construct(props) a component, you can super(props,'keyField', debugLevel) to it. If debugLevel is great than 0, messages will print out.  This will cause that component (and it's parent RASP) to print out messages on state changes.
* window.ReactActionStatePath.thiss[] is available.  Each RASP and Client component register's it's `this` in that array.  This makes it really easy to look at the state of components, and even send actions to them.
* Look at history.pushState.stateStack see to the the state of all the comonents as they have been saved.  The current state is saved each time CHILD_SHAPE_CHANGED propogates to the top, after a user event.
* Use `this.title = 'text name for this component instance' ; this.props.rasp.toParent({ type: "SET_TITLE", title: this.title }); } ` to add a text that name each component.  This will be included in debug messages. Put this in the constructor if the info is know at that time, and if not, put it in the handler for `componentWillRecieveProps()`.
* if you forget to pass rasp to a child, you will see console.error messages.

# Origin story
I created this as I was building in support for the back and forward keys of the browser in a repo for Synaccord that already had a lot going on.  (Children dynamicly selecting children). I looked at redux and react-router but it seemed like a big change and I didn't see an easy way to encode state info in the URL so the user could send a link to the same spot.  react-action-state-path is what evolved and I'm pleased by the simplicity of it and how it's worked in so many components in my code.  

I am sharing it on github in case its useful for anyone else, and I welcome any critical discussion of the concept. It is still evolving.  

# To Do

* allow and collect state from orpan components. Right now there can be only one RASP that has no parent. But it could be possible to have orphan components that still use the action to state model, and even collect state from them for the browser history.  Not sure if they could be in the path though.

* updateHistory should be a direct call to the root rather than a peer to peer call up to the root.

* fold segmentToState into actionToPath it may not need to be separate
